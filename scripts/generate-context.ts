#!/usr/bin/env tsx
/**
 * Generate schema context file for Claude /add-entry command
 *
 * This script reads all schema YAML files and generates a single
 * markdown file (schema/CONTEXT.md) that Claude can reference
 * when creating new entries.
 *
 * Usage: pnpm generate:context
 */

import fs from "node:fs";
import path from "node:path";
import { z } from "zod";
import { loadSchemaContext, SLUG_PATTERN } from "./lib/schema-loader.js";
import { SCHEMA_DIR, loadYamlFile } from "./lib/utils.js";

// =============================================================================
// CATEGORY GROUPS SCHEMA
// =============================================================================

const CategoryGroupsFileSchema = z.object({
  groups: z.record(z.string(), z.array(z.string())),
});

interface CategoryGroupsFile {
  groups: Record<string, string[]>;
}

// =============================================================================
// CATEGORY GROUP LOADING & VALIDATION
// =============================================================================

/**
 * Load category groups from YAML file and validate against canonical categories.
 * Fails loudly if any category is unmapped or if there are orphan mappings.
 */
function loadAndValidateCategoryGroups(
  categories: string[]
): Record<string, string[]> {
  const groupsPath = path.join(SCHEMA_DIR, "category-groups.yaml");

  // Load and parse the groups file
  const rawData = loadYamlFile<CategoryGroupsFile>(groupsPath);
  const parseResult = CategoryGroupsFileSchema.safeParse(rawData);

  if (!parseResult.success) {
    console.error("❌ Invalid category-groups.yaml structure:");
    for (const issue of parseResult.error.issues) {
      console.error(`   ${issue.path.join(".")}: ${issue.message}`);
    }
    process.exit(1);
  }

  const { groups } = parseResult.data;

  // Build a set of all categories in the groups file
  const mappedCategories = new Set<string>();
  const categoryToGroup = new Map<string, string>();

  for (const [groupName, groupCategories] of Object.entries(groups)) {
    for (const cat of groupCategories) {
      if (mappedCategories.has(cat)) {
        console.error(
          `❌ Category "${cat}" is mapped to multiple groups: ` +
            `"${categoryToGroup.get(cat)}" and "${groupName}"`
        );
        process.exit(1);
      }
      mappedCategories.add(cat);
      categoryToGroup.set(cat, groupName);
    }
  }

  // Check for unmapped categories (categories.yaml has category not in groups)
  const canonicalSet = new Set(categories);
  const unmappedCategories = categories.filter((c) => !mappedCategories.has(c));

  if (unmappedCategories.length > 0) {
    console.error("❌ Unmapped categories found in categories.yaml:");
    console.error(
      "   The following categories need to be added to category-groups.yaml:"
    );
    for (const cat of unmappedCategories) {
      console.error(`   - ${cat}`);
    }
    process.exit(1);
  }

  // Check for orphan mappings (groups has category not in categories.yaml)
  const orphanMappings = [...mappedCategories].filter(
    (c) => !canonicalSet.has(c)
  );

  if (orphanMappings.length > 0) {
    console.error("❌ Orphan mappings found in category-groups.yaml:");
    console.error(
      "   The following categories are mapped but don't exist in categories.yaml:"
    );
    for (const cat of orphanMappings) {
      console.error(`   - ${cat} (in group "${categoryToGroup.get(cat)}")`);
    }
    process.exit(1);
  }

  // Return groups filtered to only include categories that exist
  // (preserves group order from YAML file)
  const result: Record<string, string[]> = {};

  for (const [groupName, groupCategories] of Object.entries(groups)) {
    const validCategories = groupCategories.filter((c) => canonicalSet.has(c));
    if (validCategories.length > 0) {
      result[groupName] = validCategories;
    }
  }

  return result;
}

// =============================================================================
// MAIN
// =============================================================================

function generateContext(): void {
  const context = loadSchemaContext();

  // Load and validate category groups
  const categoryGroups = loadAndValidateCategoryGroups(context.categories);

  const output = `# Schema Context for Entry Creation

> **Auto-generated file** - Do not edit manually.
> Generated by \`pnpm generate:context\` from schema/*.yaml files.
> Last updated: ${new Date().toISOString()}

This file provides all valid values for creating new catalog entries.
Used by the \`/add-entry\` Claude command and validation scripts.

---

## Slug Format

Pattern: \`${SLUG_PATTERN.source}\`

**Rules:**
- Lowercase letters and numbers only
- Hyphens allowed between characters (not at start/end)
- Must be unique across all collections (manufacturers, software, hardware)
- Should match the filename (e.g., \`serum.yaml\` → \`slug: serum\`)

**Examples:**
- ✅ \`serum\`, \`massive-x\`, \`pro-tools\`, \`u87\`
- ❌ \`Serum\`, \`-serum\`, \`serum-\`, \`serum--x\`

---

## Categories

${Object.entries(categoryGroups)
  .map(
    ([group, cats]) => `### ${group}
${cats.map((c) => `- \`${c}\``).join("\n")}`
  )
  .join("\n\n")}

### Category Aliases

These aliases are accepted during validation and normalized to canonical form:

${Object.entries(context.categoryAliases)
  .map(([alias, canonical]) => `- \`${alias}\` → \`${canonical}\``)
  .join("\n")}

---

## Formats

Plugin and application formats:

${context.formats.map((f) => `- \`${f}\``).join("\n")}

**Notes:**
- \`au\` - Audio Unit (macOS/iOS)
- \`vst\` - Generic VST (when version unknown)
- \`vst2\` - Explicit VST2
- \`vst3\` - VST3
- \`aax\` - Pro Tools (current)
- \`rtas\` - Pro Tools (legacy)
- \`tdm\` - Pro Tools HD (legacy)
- \`clap\` - CLever Audio Plug-in
- \`lv2\` - Linux VST
- \`standalone\` - Standalone application

---

## Platforms

Supported operating systems:

${context.platforms.map((p) => `- \`${p}\``).join("\n")}

**Notes:**
- \`mac\` - macOS
- \`windows\` - Windows
- \`linux\` - Linux
- \`ios\` - iOS (AUv3)
- \`android\` - Android

---

## Locales

Approved locales for translations:

| Code | Name | Native Name |
|------|------|-------------|
${context.locales.map((l) => `| \`${l.code}\` | ${l.name} | ${l.nativeName} |`).join("\n")}

---

## Required Fields by Entry Type

### Manufacturer
- \`slug\` - URL-safe identifier
- \`name\` - Display name
- \`website\` - Company website URL

### Software
- \`slug\` - URL-safe identifier
- \`name\` - Display name
- \`manufacturer\` - Slug reference to manufacturer
- \`primaryCategory\` - Main category (from list above)
- \`platforms\` - Array of supported platforms
- \`identifiers\` - Bundle IDs per format (e.g., \`au: com.xferrecords.Serum\`)

### Hardware
- \`slug\` - URL-safe identifier
- \`name\` - Display name
- \`manufacturer\` - Slug reference to manufacturer
- \`primaryCategory\` - Main category (from list above)
- \`description\` - Short description (markdown)

---

## Notes

- **IDs are auto-assigned**: Never include \`id\` field manually - CI assigns nanoid on PR
- **Validate before commit**: Run \`pnpm validate\` to check entries
- **Format after edit**: Run \`pnpm format\` to ensure consistent YAML formatting
- **Check slug uniqueness**: Slugs must be unique across all collections
`;

  const outputPath = path.join(SCHEMA_DIR, "CONTEXT.md");
  fs.writeFileSync(outputPath, output, "utf-8");

  console.log(`✅ Generated ${outputPath}`);
}

// Run the script
generateContext();
